"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HostedGit = require("hosted-git-info");
const url = require("url");
const gitProtocols = new Set([
    'git',
    'git+http',
    'git+https',
    'git+rsync',
    'git+ftp',
    'git+file',
    'git+ssh',
]);
function parsePref(pref) {
    const hosted = HostedGit.fromUrl(pref, { noGitPlus: true, noCommittish: true });
    if (hosted) {
        return fromHostedGit(hosted);
    }
    const colonsPos = pref.indexOf(':');
    if (colonsPos === -1)
        return null;
    const protocol = pref.substr(0, colonsPos);
    if (protocol && gitProtocols.has(protocol.toLocaleLowerCase())) {
        const urlparse = url.parse(pref);
        if (!urlparse || !urlparse.protocol)
            return null;
        const match = urlparse.protocol === 'git+ssh:' && matchGitScp(pref);
        if (match) {
            return Object.assign({}, match, { normalizedPref: pref });
        }
        return Object.assign({ fetchSpec: urlToFetchSpec(urlparse), normalizedPref: pref }, setGitCommittish(urlparse.hash != null ? urlparse.hash.slice(1) : ''));
    }
    return null;
}
exports.default = parsePref;
function urlToFetchSpec(urlparse) {
    if (urlparse.protocol) {
        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '');
    }
    delete urlparse.hash;
    return url.format(urlparse);
}
function fromHostedGit(hosted) {
    return Object.assign({ fetchSpec: hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString(), hosted, normalizedPref: hosted.toString({ noGitPlus: false, noCommittish: false }) }, setGitCommittish(hosted.committish));
}
function setGitCommittish(committish) {
    if (committish != null && committish.length >= 7 && committish.slice(0, 7) === 'semver:') {
        return {
            gitCommittish: null,
            gitRange: decodeURIComponent(committish.slice(7)),
        };
    }
    return {
        gitCommittish: committish === '' ? null : committish,
    };
}
function matchGitScp(spec) {
    // git ssh specifiers are overloaded to also use scp-style git
    // specifiers, so we have to parse those out and treat them special.
    // They are NOT true URIs, so we can't hand them to `url.parse`.
    //
    // This regex looks for things that look like:
    // git+ssh://git@my.custom.git.com:username/project.git#deadbeef
    //
    // ...and various combinations. The username in the beginning is *required*.
    const matched = spec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
    return matched && !matched[1].match(/:[0-9]+\/?.*$/i) && {
        fetchSpec: matched[1],
        gitCommittish: matched[2] == null ? null : matched[2],
    };
}
//# sourceMappingURL=parsePref.js.map