"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const got = require("got");
const git = require("graceful-git");
const parsePref_1 = require("./parsePref");
const gitLogger = logger_1.default; // TODO: add namespace 'git-logger'
let tryGitHubApi = true;
function default_1(opts) {
    return function resolveGit(wantedDependency) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedSpec = parsePref_1.default(wantedDependency.pref);
            if (!parsedSpec)
                return null;
            const isGitHubHosted = parsedSpec.hosted && parsedSpec.hosted.type === 'github';
            if (!isGitHubHosted || isSsh(wantedDependency.pref)) {
                const commit = yield resolveRef(parsedSpec.fetchSpec, parsedSpec.gitCommittish || 'master');
                return {
                    id: parsedSpec.fetchSpec
                        .replace(/^.*:\/\/(git@)?/, '')
                        .replace(/:/g, '+')
                        .replace(/\.git$/, '') + '/' + commit,
                    normalizedPref: parsedSpec.normalizedPref,
                    resolution: {
                        commit,
                        repo: parsedSpec.fetchSpec,
                        type: 'git',
                    },
                };
            }
            const parts = normalizeRepoUrl(parsedSpec).split('#');
            const repo = parts[0];
            const ghSpec = {
                project: parsedSpec.hosted.project,
                ref: parsedSpec.hosted.committish || 'HEAD',
                user: parsedSpec.hosted.user,
            };
            let commitId;
            if (tryGitHubApi) {
                try {
                    commitId = yield tryResolveViaGitHubApi(ghSpec);
                }
                catch (err) {
                    gitLogger.warn({
                        err,
                        message: `Error while trying to resolve ${parsedSpec.fetchSpec} via GitHub API`,
                    });
                    // if it fails once, don't bother retrying for other packages
                    tryGitHubApi = false;
                    commitId = yield resolveRef(repo, ghSpec.ref);
                }
            }
            else {
                commitId = yield resolveRef(repo, ghSpec.ref);
            }
            const tarballResolution = {
                tarball: `https://codeload.github.com/${ghSpec.user}/${ghSpec.project}/tar.gz/${commitId}`,
            };
            return {
                id: ['github.com', ghSpec.user, ghSpec.project, commitId].join('/'),
                normalizedPref: parsedSpec.normalizedPref,
                resolution: tarballResolution,
            };
        });
    };
}
exports.default = default_1;
function resolveRef(repo, ref) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield git(['ls-remote', '--refs', repo, ref]);
        // should output something like:
        //   572bc3d4e16220c2e986091249e62a5913294b25    	refs/heads/master
        // if no ref was found, assume that ref is the commit ID
        if (!result.stdout)
            return ref;
        return result.stdout.match(/^[a-z0-9]+/)[0];
    });
}
function normalizeRepoUrl(parsedSpec) {
    const hosted = parsedSpec.hosted; // tslint:disable-line
    return hosted.getDefaultRepresentation() === 'shortcut' ? hosted.git() : hosted.toString();
}
function isSsh(gitSpec) {
    return gitSpec.substr(0, 10) === 'git+ssh://'
        || gitSpec.substr(0, 4) === 'git@';
}
/**
 * Resolves a 'hosted' package hosted on 'github'.
 */
function tryResolveViaGitHubApi(spec) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = [
            'https://api.github.com/repos',
            spec.user,
            spec.project,
            'commits',
            spec.ref,
        ].join('/');
        const response = yield got(url, { json: true });
        return response.body.sha;
    });
}
//# sourceMappingURL=index.js.map