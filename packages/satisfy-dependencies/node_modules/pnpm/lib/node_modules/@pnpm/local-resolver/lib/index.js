"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const normalize = require("normalize-path");
const path = require("path");
const readPackageJsonCB = require("read-package-json");
const promisify = require("util.promisify");
const parsePref_1 = require("./parsePref");
const readPackageJson = promisify(readPackageJsonCB);
/**
 * Resolves a package hosted on the local filesystem
 */
function resolveLocal(wantedDependency, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const spec = parsePref_1.default(wantedDependency.pref, opts.prefix);
        if (!spec)
            return null;
        const dependencyPath = normalize(path.relative(opts.prefix, spec.fetchSpec));
        const id = `file:${dependencyPath}`;
        if (spec.type === 'file') {
            return {
                id,
                normalizedPref: spec.normalizedPref,
                resolution: { tarball: id },
            };
        }
        const localPkg = yield readPackageJson(path.join(spec.fetchSpec, 'package.json'));
        return {
            id,
            normalizedPref: spec.normalizedPref,
            package: localPkg,
            resolution: {
                directory: dependencyPath,
                type: 'directory',
            },
        };
    });
}
exports.default = resolveLocal;
//# sourceMappingURL=index.js.map