"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rimraf = require("rimraf-then");
const path = require("path");
const dp = require("dependency-path");
const R = require("ramda");
const removeTopDependency_1 = require("../removeTopDependency");
const getSaveType_1 = require("../getSaveType");
const loggers_1 = require("../loggers");
function removeOrphanPkgs(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const oldPkgs = R.toPairs(R.mergeAll(R.map(depType => opts.oldShrinkwrap[depType], getSaveType_1.dependenciesTypes)));
        const newPkgs = R.toPairs(R.mergeAll(R.map(depType => opts.newShrinkwrap[depType], getSaveType_1.dependenciesTypes)));
        const removedTopDeps = R.difference(oldPkgs, newPkgs);
        const rootModules = path.join(opts.prefix, 'node_modules');
        yield Promise.all(removedTopDeps.map(depName => {
            return removeTopDependency_1.default({
                name: depName[0],
                dev: Boolean(opts.oldShrinkwrap.devDependencies && opts.oldShrinkwrap.devDependencies[depName[0]]),
                optional: Boolean(opts.oldShrinkwrap.optionalDependencies && opts.oldShrinkwrap.optionalDependencies[depName[0]]),
            }, {
                dryRun: opts.dryRun,
                modules: rootModules,
                bin: opts.bin,
            });
        }));
        const oldPkgIds = getPackageIds(opts.oldShrinkwrap.registry, opts.oldShrinkwrap.packages || {});
        const newPkgIds = getPackageIds(opts.newShrinkwrap.registry, opts.newShrinkwrap.packages || {});
        const notDependents = R.difference(oldPkgIds, newPkgIds);
        loggers_1.statsLogger.debug({ removed: notDependents.length });
        if (!opts.dryRun) {
            if (notDependents.length) {
                if (opts.shamefullyFlatten && opts.oldShrinkwrap.packages) {
                    yield Promise.all(notDependents.map((notDependent) => __awaiter(this, void 0, void 0, function* () {
                        if (opts.hoistedAliases[notDependent]) {
                            yield Promise.all(opts.hoistedAliases[notDependent].map((alias) => __awaiter(this, void 0, void 0, function* () {
                                yield removeTopDependency_1.default({
                                    name: alias,
                                    dev: false,
                                    optional: false,
                                }, {
                                    modules: rootModules,
                                    bin: opts.bin,
                                    muteLogs: true
                                });
                            })));
                        }
                        delete opts.hoistedAliases[notDependent];
                    })));
                }
                yield Promise.all(notDependents.map((notDependent) => __awaiter(this, void 0, void 0, function* () {
                    yield rimraf(path.join(rootModules, `.${notDependent}`));
                })));
            }
            const newDependents = R.difference(newPkgIds, oldPkgIds);
            yield opts.storeController.updateConnections(opts.prefix, {
                prune: opts.pruneStore || false,
                removeDependencies: notDependents,
                addDependencies: newDependents,
            });
            yield opts.storeController.saveState();
        }
        return new Set(notDependents);
    });
}
exports.default = removeOrphanPkgs;
function getPackageIds(registry, packages) {
    return R.uniq(R.keys(packages)
        .map(depPath => {
        if (packages[depPath].id) {
            return packages[depPath].id;
        }
        return dp.resolve(registry, depPath);
    }));
}
//# sourceMappingURL=removeOrphanPkgs.js.map