"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logger_1 = require("@pnpm/logger");
const loggers_1 = require("./loggers");
const R = require("ramda");
const get_npm_tarball_url_1 = require("get-npm-tarball-url");
const exists = require("path-exists");
const url = require("url");
const logInstallStatus_1 = require("./logging/logInstallStatus");
const dp = require("dependency-path");
const depsToSpecs_1 = require("./depsToSpecs");
const getIsInstallable_1 = require("./install/getIsInstallable");
const getPkgInfoFromShr_1 = require("./getPkgInfoFromShr");
const nodeIdUtils_1 = require("./nodeIdUtils");
const encodePkgId_1 = require("./encodePkgId");
const semver = require("semver");
const ENGINE_NAME = `${process.platform}-${process.arch}-node-${process.version.split('.')[0]}`;
function resolveDependencies(ctx, wantedDependencies, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolvedDependencies = options.resolvedDependencies || {};
        const preferedDependencies = options.preferedDependencies || {};
        const update = options.update && options.currentDepth <= ctx.depth;
        const pkgAddresses = (yield Promise.all(wantedDependencies
            .map((wantedDependency) => __awaiter(this, void 0, void 0, function* () {
            let reference = wantedDependency.alias && resolvedDependencies[wantedDependency.alias];
            let proceed = false;
            // If dependencies that were used by the previous version of the package
            // satisfy the newer version's requirements, then pnpm tries to keep
            // the previous dependency.
            // So for example, if foo@1.0.0 had bar@1.0.0 as a dependency
            // and foo was updated to 1.1.0 which depends on bar ^1.0.0
            // then bar@1.0.0 can be reused for foo@1.1.0
            if (!reference && wantedDependency.alias && semver.validRange(wantedDependency.pref) !== null &&
                preferedDependencies[wantedDependency.alias] &&
                refSatisfies(preferedDependencies[wantedDependency.alias], wantedDependency.pref)) {
                proceed = true;
                reference = preferedDependencies[wantedDependency.alias];
            }
            return yield install(wantedDependency, ctx, Object.assign({ keypath: options.keypath, parentNodeId: options.parentNodeId, currentDepth: options.currentDepth, parentIsInstallable: options.parentIsInstallable, readPackageHook: options.readPackageHook, hasManifestInShrinkwrap: options.hasManifestInShrinkwrap, update,
                proceed, reinstallForFlatten: options.reinstallForFlatten, shamefullyFlatten: options.shamefullyFlatten, sideEffectsCache: options.sideEffectsCache }, getInfoFromShrinkwrap(ctx.wantedShrinkwrap, reference, wantedDependency.alias, ctx.registry)));
        }))))
            .filter(Boolean);
        return pkgAddresses;
    });
}
exports.default = resolveDependencies;
// A reference is not always a version.
// We assume that it does not satisfy the range if it's raw form is not a version
// This logic can be made smarter because
// if the reference is /foo/1.0.0/bar@2.0.0, foo's version if 1.0.0
function refSatisfies(reference, range) {
    try {
        return semver.satisfies(reference, range, true);
    }
    catch (err) {
        return false;
    }
}
function getInfoFromShrinkwrap(shrinkwrap, reference, pkgName, registry) {
    if (!reference || !pkgName) {
        return null;
    }
    const relDepPath = dp.refToRelative(reference, pkgName);
    if (!relDepPath) {
        return null;
    }
    const dependencyShrinkwrap = shrinkwrap.packages && shrinkwrap.packages[relDepPath];
    if (dependencyShrinkwrap) {
        const depPath = dp.resolve(shrinkwrap.registry, relDepPath);
        return {
            relDepPath,
            depPath,
            dependencyShrinkwrap,
            pkgId: dependencyShrinkwrap.id || depPath,
            shrinkwrapResolution: dependencyShrToResolution(relDepPath, dependencyShrinkwrap, shrinkwrap.registry),
            resolvedDependencies: Object.assign({}, dependencyShrinkwrap.dependencies, dependencyShrinkwrap.optionalDependencies),
            optionalDependencyNames: R.keys(dependencyShrinkwrap.optionalDependencies),
        };
    }
    else {
        return {
            relDepPath,
            pkgId: dp.resolve(shrinkwrap.registry, relDepPath),
        };
    }
}
function dependencyShrToResolution(relDepPath, depShr, registry) {
    if (depShr.resolution['type']) {
        return depShr.resolution;
    }
    if (!depShr.resolution['tarball']) {
        return Object.assign({}, depShr.resolution, { tarball: getTarball(), registry: depShr.resolution['registry'] || registry });
    }
    if (depShr.resolution['tarball'].startsWith('file:')) {
        return depShr.resolution;
    }
    return Object.assign({}, depShr.resolution, { tarball: url.resolve(registry, depShr.resolution['tarball']) });
    function getTarball() {
        const parsed = dp.parse(relDepPath);
        if (!parsed['name'] || !parsed['version']) {
            throw new Error(`Couldn't get tarball URL from dependency path ${relDepPath}`);
        }
        return get_npm_tarball_url_1.default(parsed['name'], parsed['version'], { registry });
    }
}
function install(wantedDependency, ctx, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const keypath = options.keypath || [];
        const proceed = options.proceed || !options.shrinkwrapResolution || ctx.force || keypath.length <= ctx.depth;
        const parentIsInstallable = options.parentIsInstallable === undefined || options.parentIsInstallable;
        if (!options.shamefullyFlatten && !options.reinstallForFlatten && !proceed && options.depPath &&
            // if package is not in `node_modules/.shrinkwrap.yaml`
            // we can safely assume that it doesn't exist in `node_modules`
            options.relDepPath && ctx.currentShrinkwrap.packages && ctx.currentShrinkwrap.packages[options.relDepPath] &&
            (yield exists(path.join(ctx.nodeModules, `.${options.depPath}`))) && (options.currentDepth > 0 || wantedDependency.alias && (yield exists(path.join(ctx.nodeModules, wantedDependency.alias))))) {
            return null;
        }
        const scope = wantedDependency.alias && getScope(wantedDependency.alias);
        const registry = normalizeRegistry(scope && ctx.rawNpmConfig[`${scope}:registry`] || ctx.registry);
        const dependentId = keypath[keypath.length - 1];
        const loggedPkg = {
            rawSpec: wantedDependency.raw,
            name: wantedDependency.alias,
            dependentId,
        };
        logInstallStatus_1.default({
            status: 'installing',
            pkg: loggedPkg,
        });
        let pkgResponse;
        try {
            pkgResponse = yield ctx.storeController.requestPackage(wantedDependency, {
                defaultTag: ctx.defaultTag,
                loggedPkg,
                update: options.update,
                registry,
                prefix: ctx.prefix,
                shrinkwrapResolution: options.shrinkwrapResolution,
                currentPkgId: options.pkgId,
                verifyStoreIntegrity: ctx.verifyStoreInegrity,
                downloadPriority: -options.currentDepth,
                preferredVersions: ctx.preferredVersions,
                skipFetch: ctx.dryRun,
                sideEffectsCache: options.sideEffectsCache
            });
        }
        catch (err) {
            if (wantedDependency.optional) {
                logger_1.default.warn({
                    message: `Skipping optional dependency ${wantedDependency.raw}. ${err.toString()}`,
                    err,
                });
                return null;
            }
            throw err;
        }
        pkgResponse.body.id = encodePkgId_1.default(pkgResponse.body.id);
        if (pkgResponse.body.isLocal) {
            const pkg = pkgResponse.body.manifest || (yield pkgResponse['fetchingManifest']);
            if (options.currentDepth > 0) {
                logger_1.default.warn(`Ignoring file dependency because it is not a root dependency ${wantedDependency}`);
            }
            else {
                ctx.localPackages.push({
                    alias: wantedDependency.alias || pkg.name,
                    id: pkgResponse.body.id,
                    specRaw: wantedDependency.raw,
                    name: pkg.name,
                    version: pkg.version,
                    dev: wantedDependency.dev,
                    optional: wantedDependency.optional,
                    resolution: pkgResponse.body.resolution,
                    normalizedPref: pkgResponse.body.normalizedPref,
                });
            }
            logInstallStatus_1.default({ status: 'downloaded_manifest', pkgId: pkgResponse.body.id, pkgVersion: pkg.version });
            return null;
        }
        // For the root dependency dependentId will be undefined,
        // that's why checking it
        if (dependentId && nodeIdUtils_1.nodeIdContainsSequence(options.parentNodeId, dependentId, pkgResponse.body.id)) {
            return null;
        }
        let pkg;
        let useManifestInfoFromShrinkwrap = false;
        if (options.hasManifestInShrinkwrap && !options.update && options.dependencyShrinkwrap && options.relDepPath) {
            useManifestInfoFromShrinkwrap = true;
            pkg = Object.assign(getPkgInfoFromShr_1.default(options.relDepPath, options.dependencyShrinkwrap), options.dependencyShrinkwrap);
            if (pkg.peerDependencies) {
                const deps = pkg.dependencies || {};
                R.keys(pkg.peerDependencies).forEach(peer => {
                    delete deps[peer];
                    if (options.resolvedDependencies) {
                        delete options.resolvedDependencies[peer];
                    }
                });
            }
        }
        else {
            try {
                pkg = options.readPackageHook
                    ? options.readPackageHook(pkgResponse.body['manifest'] || (yield pkgResponse['fetchingManifest']))
                    : pkgResponse.body['manifest'] || (yield pkgResponse['fetchingManifest']);
            }
            catch (err) {
                // avoiding unhandled promise rejections
                if (pkgResponse['finishing'])
                    pkgResponse['finishing'].catch((err) => { });
                if (pkgResponse['fetchingFiles'])
                    pkgResponse['fetchingFiles'].catch((err) => { });
                throw err;
            }
        }
        if (options.currentDepth === 0 && pkgResponse.body.latest && pkgResponse.body.latest !== pkg.version) {
            ctx.outdatedPkgs[pkgResponse.body.id] = pkgResponse.body.latest;
        }
        if (pkg.deprecated) {
            loggers_1.deprecationLogger.warn({
                pkgName: pkg.name,
                pkgVersion: pkg.version,
                pkgId: pkgResponse.body.id,
                deprecated: pkg.deprecated,
                depth: options.currentDepth,
            });
        }
        logInstallStatus_1.default({ status: 'downloaded_manifest', pkgId: pkgResponse.body.id, pkgVersion: pkg.version });
        // using colon as it will never be used inside a package ID
        const nodeId = nodeIdUtils_1.createNodeId(options.parentNodeId, pkgResponse.body.id);
        const currentIsInstallable = (ctx.force ||
            (yield getIsInstallable_1.default(pkgResponse.body.id, pkg, {
                nodeId,
                installs: ctx.installs,
                optional: wantedDependency.optional,
                engineStrict: ctx.engineStrict,
                nodeVersion: ctx.nodeVersion,
                pnpmVersion: ctx.pnpmVersion,
            })));
        const installable = parentIsInstallable && currentIsInstallable;
        if (installable) {
            ctx.skipped.delete(pkgResponse.body.id);
        }
        if (!ctx.installs[pkgResponse.body.id]) {
            if (!installable) {
                // optional dependencies are resolved for consistent shrinkwrap.yaml files
                // but installed only on machines that are supported by the package
                ctx.skipped.add(pkgResponse.body.id);
            }
            const peerDependencies = peerDependenciesWithoutOwn(pkg);
            ctx.installs[pkgResponse.body.id] = {
                id: pkgResponse.body.id,
                resolution: pkgResponse.body.resolution,
                optional: wantedDependency.optional,
                name: pkg.name,
                version: pkg.version,
                prod: !wantedDependency.dev && !wantedDependency.optional,
                dev: wantedDependency.dev,
                fetchingFiles: pkgResponse['fetchingFiles'],
                finishing: pkgResponse['finishing'],
                path: pkgResponse.body.inStoreLocation,
                specRaw: wantedDependency.raw,
                peerDependencies: peerDependencies || {},
                optionalDependencies: new Set(R.keys(pkg.optionalDependencies)),
                hasBundledDependencies: !!(pkg.bundledDependencies || pkg.bundleDependencies),
                additionalInfo: {
                    deprecated: pkg.deprecated,
                    peerDependencies,
                    bundleDependencies: pkg.bundleDependencies,
                    bundledDependencies: pkg.bundledDependencies,
                    engines: pkg.engines,
                    cpu: pkg.cpu,
                    os: pkg.os,
                },
                engineCache: !ctx.force && pkgResponse.body.cacheByEngine && pkgResponse.body.cacheByEngine[ENGINE_NAME],
            };
            const children = yield resolveDependenciesOfPackage(pkg, ctx, {
                parentIsInstallable: installable,
                currentDepth: options.currentDepth + 1,
                parentNodeId: nodeId,
                keypath: options.keypath.concat([pkgResponse.body.id]),
                resolvedDependencies: pkgResponse.body.id !== options.pkgId
                    ? undefined
                    : options.resolvedDependencies,
                preferedDependencies: pkgResponse.body.id !== options.pkgId
                    ? options.resolvedDependencies
                    : undefined,
                optionalDependencyNames: options.optionalDependencyNames,
                update: options.update,
                readPackageHook: options.readPackageHook,
                hasManifestInShrinkwrap: options.hasManifestInShrinkwrap,
                useManifestInfoFromShrinkwrap,
                sideEffectsCache: options.sideEffectsCache,
                reinstallForFlatten: options.reinstallForFlatten,
                shamefullyFlatten: options.shamefullyFlatten,
            });
            ctx.childrenByParentId[pkgResponse.body.id] = children.map(child => ({
                alias: child.alias,
                pkgId: child.pkgId,
            }));
            ctx.tree[nodeId] = {
                pkg: ctx.installs[pkgResponse.body.id],
                children: children.reduce((children, child) => {
                    children[child.alias] = child.nodeId;
                    return children;
                }, {}),
                depth: options.currentDepth,
                installable,
            };
        }
        else {
            ctx.installs[pkgResponse.body.id].prod = ctx.installs[pkgResponse.body.id].prod || !wantedDependency.dev && !wantedDependency.optional;
            ctx.installs[pkgResponse.body.id].dev = ctx.installs[pkgResponse.body.id].dev || wantedDependency.dev;
            ctx.installs[pkgResponse.body.id].optional = ctx.installs[pkgResponse.body.id].optional && wantedDependency.optional;
            ctx.nodesToBuild.push({
                alias: wantedDependency.alias || pkg.name,
                nodeId,
                pkg: ctx.installs[pkgResponse.body.id],
                depth: options.currentDepth,
                installable,
            });
        }
        // we need this for saving to package.json
        if (options.currentDepth === 0) {
            ctx.installs[pkgResponse.body.id].specRaw = wantedDependency.raw;
        }
        logInstallStatus_1.default({ status: 'dependencies_installed', pkgId: pkgResponse.body.id });
        return {
            alias: wantedDependency.alias || pkg.name,
            nodeId,
            pkgId: pkgResponse.body.id,
            normalizedPref: options.currentDepth === 0 ? pkgResponse.body.normalizedPref : undefined,
        };
    });
}
function getScope(pkgName) {
    if (pkgName[0] === '@') {
        return pkgName.substr(0, pkgName.indexOf('/'));
    }
    return null;
}
function peerDependenciesWithoutOwn(pkg) {
    if (!pkg.peerDependencies)
        return pkg.peerDependencies;
    const ownDeps = new Set(R.keys(pkg.dependencies).concat(R.keys(pkg.optionalDependencies)));
    const result = {};
    for (let peer of R.keys(pkg.peerDependencies)) {
        if (ownDeps.has(peer))
            continue;
        result[peer] = pkg.peerDependencies[peer];
    }
    if (R.isEmpty(result))
        return undefined;
    return result;
}
function normalizeRegistry(registry) {
    if (registry.endsWith('/'))
        return registry;
    return `${registry}/`;
}
function resolveDependenciesOfPackage(pkg, ctx, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundledDeps = pkg.bundleDependencies || pkg.bundledDependencies || [];
        const filterDeps = getNotBundledDeps.bind(null, bundledDeps);
        let deps = depsToSpecs_1.default(filterDeps(Object.assign({}, pkg.optionalDependencies, pkg.dependencies)), {
            devDependencies: {},
            optionalDependencies: pkg.optionalDependencies || {},
        });
        if (opts.hasManifestInShrinkwrap && !deps.length && opts.resolvedDependencies && opts.useManifestInfoFromShrinkwrap) {
            const optionalDependencyNames = opts.optionalDependencyNames || [];
            deps = R.keys(opts.resolvedDependencies)
                .map(depName => ({
                alias: depName,
                optional: optionalDependencyNames.indexOf(depName) !== -1,
            }));
        }
        return yield resolveDependencies(ctx, deps, opts);
    });
}
function getNotBundledDeps(bundledDeps, deps) {
    return Object.keys(deps)
        .filter(depName => bundledDeps.indexOf(depName) === -1)
        .reduce((notBundledDeps, depName) => {
        notBundledDeps[depName] = deps[depName];
        return notBundledDeps;
    }, {});
}
//# sourceMappingURL=resolveDependencies.js.map