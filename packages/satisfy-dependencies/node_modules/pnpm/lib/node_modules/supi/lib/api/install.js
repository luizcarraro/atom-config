"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dp = require("dependency-path");
const path = require("path");
const logger_1 = require("@pnpm/logger");
const loggers_1 = require("../loggers");
const logInstallStatus_1 = require("../logging/logInstallStatus");
const pLimit = require("p-limit");
const pFilter = require("p-filter");
const R = require("ramda");
const safeIsInnerLink_1 = require("../safeIsInnerLink");
const safeReadPkg_1 = require("../fs/safeReadPkg");
const getContext_1 = require("./getContext");
const resolveDependencies_1 = require("../resolveDependencies");
const link_1 = require("./link");
const link_2 = require("../link");
const save_1 = require("../save");
const getSaveType_1 = require("../getSaveType");
const postInstall_1 = require("../install/postInstall");
const extendInstallOptions_1 = require("./extendInstallOptions");
const lock_1 = require("./lock");
const pnpm_shrinkwrap_1 = require("pnpm-shrinkwrap");
const shrinkwrap_1 = require("../fs/shrinkwrap");
const modulesController_1 = require("../fs/modulesController");
const depsToSpecs_1 = require("../depsToSpecs");
const shrinkwrapsEqual_1 = require("./shrinkwrapsEqual");
const depsFromPackage_1 = require("../depsFromPackage");
const parseWantedDependencies_1 = require("../parseWantedDependencies");
const nodeIdUtils_1 = require("../nodeIdUtils");
const ENGINE_NAME = `${process.platform}-${process.arch}-node-${process.version.split('.')[0]}`;
function install(maybeOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        const reporter = maybeOpts && maybeOpts.reporter;
        if (reporter) {
            logger_1.streamParser.on('data', reporter);
        }
        const opts = yield extendInstallOptions_1.default(maybeOpts);
        if (!opts.production && opts.optional) {
            throw new Error('Optional dependencies cannot be installed without production dependencies');
        }
        if (opts.lock) {
            yield lock_1.default(opts.prefix, _install, { stale: opts.lockStaleDuration, locks: opts.locks });
        }
        else {
            yield _install();
        }
        if (reporter) {
            logger_1.streamParser.removeListener('data', reporter);
        }
        function _install() {
            return __awaiter(this, void 0, void 0, function* () {
                const installType = 'general';
                const ctx = yield getContext_1.default(opts, installType);
                if (!ctx.pkg)
                    throw new Error('No package.json found');
                const preferredVersions = depsFromPackage_1.getPreferredVersionsFromPackage(ctx.pkg);
                const specs = specsToInstallFromPackage(ctx.pkg, {
                    prefix: opts.prefix,
                });
                if (ctx.wantedShrinkwrap.specifiers) {
                    ctx.wantedShrinkwrap.dependencies = ctx.wantedShrinkwrap.dependencies || {};
                    ctx.wantedShrinkwrap.devDependencies = ctx.wantedShrinkwrap.devDependencies || {};
                    ctx.wantedShrinkwrap.optionalDependencies = ctx.wantedShrinkwrap.optionalDependencies || {};
                    for (const spec of specs) {
                        if (spec.alias && ctx.wantedShrinkwrap.specifiers[spec.alias] !== spec.pref) {
                            delete ctx.wantedShrinkwrap.dependencies[spec.alias];
                            delete ctx.wantedShrinkwrap.devDependencies[spec.alias];
                            delete ctx.wantedShrinkwrap.optionalDependencies[spec.alias];
                        }
                    }
                }
                const scripts = !opts.ignoreScripts && ctx.pkg && ctx.pkg.scripts || {};
                if (scripts['prepublish']) {
                    logger_1.default.warn('`prepublish` scripts are deprecated. Use `prepare` for build steps and `prepublishOnly` for upload-only.');
                }
                const scriptsOpts = {
                    rawNpmConfig: opts.rawNpmConfig,
                    modulesDir: path.join(opts.prefix, 'node_modules'),
                    root: opts.prefix,
                    pkgId: opts.prefix,
                    stdio: 'inherit',
                    unsafePerm: opts.unsafePerm || false,
                };
                if (scripts['preinstall']) {
                    yield postInstall_1.npmRunScript('preinstall', ctx.pkg, scriptsOpts);
                }
                yield installInContext(installType, specs, [], ctx, preferredVersions, opts);
                if (scripts['install']) {
                    yield postInstall_1.npmRunScript('install', ctx.pkg, scriptsOpts);
                }
                if (scripts['postinstall']) {
                    yield postInstall_1.npmRunScript('postinstall', ctx.pkg, scriptsOpts);
                }
                if (scripts['prepublish']) {
                    yield postInstall_1.npmRunScript('prepublish', ctx.pkg, scriptsOpts);
                }
                if (scripts['prepare']) {
                    yield postInstall_1.npmRunScript('prepare', ctx.pkg, scriptsOpts);
                }
            });
        }
    });
}
exports.install = install;
function specsToInstallFromPackage(pkg, opts) {
    const depsToInstall = depsFromPackage_1.default(pkg);
    return depsToSpecs_1.default(depsToInstall, {
        optionalDependencies: pkg.optionalDependencies || {},
        devDependencies: pkg.devDependencies || {},
    });
}
/**
 * Perform installation.
 *
 * @example
 *     install({'lodash': '1.0.0', 'foo': '^2.1.0' }, { silent: true })
 */
function installPkgs(fuzzyDeps, maybeOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        const reporter = maybeOpts && maybeOpts.reporter;
        if (reporter) {
            logger_1.streamParser.on('data', reporter);
        }
        if (maybeOpts.update === undefined)
            maybeOpts.update = true;
        const opts = yield extendInstallOptions_1.default(maybeOpts);
        if (opts.lock) {
            yield lock_1.default(opts.prefix, _installPkgs, { stale: opts.lockStaleDuration, locks: opts.locks });
        }
        else {
            yield _installPkgs();
        }
        if (reporter) {
            logger_1.streamParser.removeListener('data', reporter);
        }
        function _installPkgs() {
            return __awaiter(this, void 0, void 0, function* () {
                const installType = 'named';
                const ctx = yield getContext_1.default(opts, installType);
                const currentPrefs = opts.global ? {} : depsFromPackage_1.default(ctx.pkg);
                const saveType = getSaveType_1.default(opts);
                const optionalDependencies = saveType ? {} : ctx.pkg.optionalDependencies || {};
                const devDependencies = saveType ? {} : ctx.pkg.devDependencies || {};
                let packagesToInstall = Array.isArray(fuzzyDeps)
                    ? parseWantedDependencies_1.default(fuzzyDeps, {
                        defaultTag: opts.tag,
                        dev: opts.saveDev,
                        optional: opts.saveOptional,
                        currentPrefs,
                        optionalDependencies,
                        devDependencies,
                    })
                    : depsToSpecs_1.similarDepsToSpecs(fuzzyDeps, {
                        dev: opts.saveDev,
                        optional: opts.saveOptional,
                        currentPrefs,
                        optionalDependencies,
                        devDependencies,
                    });
                if (!Object.keys(packagesToInstall).length && !opts.reinstallForFlatten) {
                    throw new Error('At least one package has to be installed');
                }
                const preferredVersions = depsFromPackage_1.getPreferredVersionsFromPackage(ctx.pkg);
                return installInContext(installType, packagesToInstall, packagesToInstall.map(wantedDependency => wantedDependency.raw), ctx, preferredVersions, opts);
            });
        }
    });
}
exports.installPkgs = installPkgs;
function installInContext(installType, packagesToInstall, newPkgRawSpecs, ctx, preferredVersions, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        // Unfortunately, the private shrinkwrap file may differ from the public one.
        // A user might run named installations on a project that has a shrinkwrap.yaml file before running a noop install
        const makePartialCurrentShrinkwrap = installType === 'named' && (ctx.existsWantedShrinkwrap && !ctx.existsCurrentShrinkwrap ||
            // TODO: this operation is quite expensive. We'll have to find a better solution to do this.
            // maybe in pnpm v2 it won't be needed. See: https://github.com/pnpm/pnpm/issues/841
            !shrinkwrapsEqual_1.default(ctx.currentShrinkwrap, ctx.wantedShrinkwrap));
        if (opts.shrinkwrapOnly && ctx.existsCurrentShrinkwrap) {
            logger_1.default.warn('`node_modules` is present. Shrinkwrap only installation will make it out-of-date');
        }
        const nodeModulesPath = path.join(ctx.root, 'node_modules');
        // This works from minor version 1, so any number is fine
        // also, the shrinkwrapMinorVersion is going to be removed from shrinkwrap v4
        const hasManifestInShrinkwrap = typeof ctx.wantedShrinkwrap.shrinkwrapMinorVersion === 'number';
        const installCtx = {
            defaultTag: opts.tag,
            dryRun: opts.shrinkwrapOnly,
            installs: {},
            outdatedPkgs: {},
            localPackages: [],
            childrenByParentId: {},
            nodesToBuild: [],
            wantedShrinkwrap: ctx.wantedShrinkwrap,
            currentShrinkwrap: ctx.currentShrinkwrap,
            skipped: ctx.skipped,
            tree: {},
            registry: ctx.wantedShrinkwrap.registry,
            force: opts.force,
            depth: (function () {
                // This can be remove from shrinkwrap v4
                if (!hasManifestInShrinkwrap) {
                    // The shrinkwrap file has to be updated to contain
                    // the necessary info from package manifests
                    return Infinity;
                }
                if (opts.update) {
                    return opts.depth;
                }
                if (R.equals(ctx.wantedShrinkwrap.packages, ctx.currentShrinkwrap.packages)) {
                    return opts.repeatInstallDepth;
                }
                return Infinity;
            })(),
            prefix: opts.prefix,
            rawNpmConfig: opts.rawNpmConfig,
            nodeModules: nodeModulesPath,
            verifyStoreInegrity: opts.verifyStoreIntegrity,
            engineStrict: opts.engineStrict,
            nodeVersion: opts.nodeVersion,
            pnpmVersion: opts.packageManager.name === 'pnpm' ? opts.packageManager.version : '',
            storeController: opts.storeController,
            preferredVersions,
        };
        const installOpts = {
            root: ctx.root,
            resolvedDependencies: Object.assign({}, ctx.wantedShrinkwrap.devDependencies, ctx.wantedShrinkwrap.dependencies, ctx.wantedShrinkwrap.optionalDependencies),
            update: opts.update,
            keypath: [],
            parentNodeId: nodeIdUtils_1.ROOT_NODE_ID,
            currentDepth: 0,
            readPackageHook: opts.hooks.readPackage,
            hasManifestInShrinkwrap,
            sideEffectsCache: opts.sideEffectsCache,
            reinstallForFlatten: opts.reinstallForFlatten,
            shamefullyFlatten: opts.shamefullyFlatten,
        };
        const nonLinkedPkgs = yield pFilter(packagesToInstall, (wantedDependency) => __awaiter(this, void 0, void 0, function* () {
            if (!wantedDependency.alias)
                return true;
            const isInnerLink = yield safeIsInnerLink_1.default(nodeModulesPath, wantedDependency.alias, {
                storePath: ctx.storePath,
            });
            if (isInnerLink === true)
                return true;
            loggers_1.rootLogger.debug({
                linked: {
                    name: wantedDependency.alias,
                    from: isInnerLink,
                    to: nodeModulesPath,
                    dependencyType: wantedDependency.dev && 'dev' || wantedDependency.optional && 'optional' || 'prod',
                },
            });
            // This info-log might be better to be moved to the reporter
            logger_1.default.info(`${wantedDependency.alias} is linked to ${nodeModulesPath} from ${isInnerLink}`);
            return false;
        }));
        loggers_1.stageLogger.debug('resolution_started');
        const rootPkgs = yield resolveDependencies_1.default(installCtx, nonLinkedPkgs, installOpts);
        loggers_1.stageLogger.debug('resolution_done');
        installCtx.nodesToBuild.forEach(nodeToBuild => {
            installCtx.tree[nodeToBuild.nodeId] = {
                pkg: nodeToBuild.pkg,
                children: () => buildTree(installCtx, nodeToBuild.nodeId, nodeToBuild.pkg.id, installCtx.childrenByParentId[nodeToBuild.pkg.id], nodeToBuild.depth + 1, nodeToBuild.installable),
                depth: nodeToBuild.depth,
                installable: nodeToBuild.installable,
            };
        });
        const rootNodeIdsByAlias = rootPkgs
            .reduce((rootNodeIdsByAlias, rootPkg) => {
            const pkg = installCtx.tree[rootPkg.nodeId].pkg;
            const specRaw = pkg.specRaw;
            const spec = R.find(spec => spec.raw === specRaw, packagesToInstall);
            rootNodeIdsByAlias[rootPkg.alias] = rootPkg.nodeId;
            return rootNodeIdsByAlias;
        }, {});
        const pkgsToSave = rootPkgs
            .map(rootPkg => (Object.assign({}, installCtx.tree[rootPkg.nodeId].pkg, { alias: rootPkg.alias, normalizedPref: rootPkg.normalizedPref })))
            .concat(installCtx.localPackages);
        let newPkg = ctx.pkg;
        if (installType === 'named' && !opts.reinstallForFlatten) {
            if (!ctx.pkg) {
                throw new Error('Cannot save because no package.json found');
            }
            const pkgJsonPath = path.join(ctx.root, 'package.json');
            const saveType = getSaveType_1.default(opts);
            newPkg = yield save_1.default(pkgJsonPath, pkgsToSave // tslint:disable-line
                .map(dep => {
                return {
                    name: dep.alias,
                    pref: dep.normalizedPref || getPref(dep.alias, dep.name, dep.version, {
                        saveExact: opts.saveExact,
                        savePrefix: opts.savePrefix,
                    })
                };
            }), saveType);
        }
        else {
            loggers_1.packageJsonLogger.debug({ updated: ctx.pkg });
        }
        if (newPkg) {
            ctx.wantedShrinkwrap.dependencies = ctx.wantedShrinkwrap.dependencies || {};
            ctx.wantedShrinkwrap.specifiers = ctx.wantedShrinkwrap.specifiers || {};
            ctx.wantedShrinkwrap.optionalDependencies = ctx.wantedShrinkwrap.optionalDependencies || {};
            ctx.wantedShrinkwrap.devDependencies = ctx.wantedShrinkwrap.devDependencies || {};
            const deps = newPkg.dependencies || {};
            const devDeps = newPkg.devDependencies || {};
            const optionalDeps = newPkg.optionalDependencies || {};
            const getSpecFromPkg = (depName) => deps[depName] || devDeps[depName] || optionalDeps[depName];
            for (const dep of pkgsToSave) {
                const ref = shrinkwrap_1.absolutePathToRef(dep.id, {
                    alias: dep.alias,
                    realName: dep.name,
                    resolution: dep.resolution,
                    standardRegistry: ctx.wantedShrinkwrap.registry,
                });
                const isDev = !!devDeps[dep.alias];
                const isOptional = !!optionalDeps[dep.alias];
                if (isDev) {
                    ctx.wantedShrinkwrap.devDependencies[dep.alias] = ref;
                }
                else if (isOptional) {
                    ctx.wantedShrinkwrap.optionalDependencies[dep.alias] = ref;
                }
                else {
                    ctx.wantedShrinkwrap.dependencies[dep.alias] = ref;
                }
                if (!isDev) {
                    delete ctx.wantedShrinkwrap.devDependencies[dep.alias];
                }
                if (!isOptional) {
                    delete ctx.wantedShrinkwrap.optionalDependencies[dep.alias];
                }
                if (isDev || isOptional) {
                    delete ctx.wantedShrinkwrap.dependencies[dep.alias];
                }
                ctx.wantedShrinkwrap.specifiers[dep.alias] = getSpecFromPkg(dep.alias);
            }
        }
        const topParents = ctx.pkg
            ? yield getTopParents(R.difference(R.keys(depsFromPackage_1.default(ctx.pkg)), newPkgRawSpecs && pkgsToSave.filter(pkgToSave => newPkgRawSpecs.indexOf(pkgToSave.specRaw) !== -1).map(pkg => pkg.alias) || []), nodeModulesPath)
            : [];
        const result = yield link_2.default(rootNodeIdsByAlias, installCtx.tree, {
            dryRun: opts.shrinkwrapOnly,
            force: opts.force,
            global: opts.global,
            baseNodeModules: nodeModulesPath,
            bin: opts.bin,
            topParents,
            wantedShrinkwrap: ctx.wantedShrinkwrap,
            production: opts.production,
            development: opts.development,
            optional: opts.optional,
            root: ctx.root,
            currentShrinkwrap: ctx.currentShrinkwrap,
            skipped: ctx.skipped,
            pkg: newPkg || ctx.pkg,
            independentLeaves: opts.independentLeaves,
            storeController: opts.storeController,
            makePartialCurrentShrinkwrap,
            updateShrinkwrapMinorVersion: installType === 'general' || R.isEmpty(ctx.currentShrinkwrap.packages),
            outdatedPkgs: installCtx.outdatedPkgs,
            sideEffectsCache: opts.sideEffectsCache,
            shamefullyFlatten: opts.shamefullyFlatten,
            reinstallForFlatten: Boolean(opts.reinstallForFlatten),
            hoistedAliases: ctx.hoistedAliases,
        });
        ctx.hoistedAliases = result.hoistedAliases;
        ctx.pendingBuilds = ctx.pendingBuilds
            .filter(pkgId => !result.removedPkgIds.has(dp.resolve(ctx.wantedShrinkwrap.registry, pkgId)));
        if (opts.ignoreScripts) {
            // we can use concat here because we always only append new packages, which are guaranteed to not be there by definition
            ctx.pendingBuilds = ctx.pendingBuilds
                .concat(result.newDepPaths.map(depPath => dp.relative(ctx.wantedShrinkwrap.registry, depPath)));
        }
        if (opts.shrinkwrapOnly) {
            yield pnpm_shrinkwrap_1.writeWantedOnly(ctx.root, result.wantedShrinkwrap);
        }
        else {
            yield Promise.all([
                opts.shrinkwrap
                    ? pnpm_shrinkwrap_1.write(ctx.root, result.wantedShrinkwrap, result.currentShrinkwrap)
                    : pnpm_shrinkwrap_1.writeCurrentOnly(ctx.root, result.currentShrinkwrap),
                result.currentShrinkwrap.packages === undefined && result.removedPkgIds.size === 0
                    ? Promise.resolve()
                    : modulesController_1.save(path.join(ctx.root, 'node_modules'), {
                        packageManager: `${opts.packageManager.name}@${opts.packageManager.version}`,
                        store: ctx.storePath,
                        skipped: Array.from(installCtx.skipped),
                        layoutVersion: modulesController_1.LAYOUT_VERSION,
                        independentLeaves: opts.independentLeaves,
                        pendingBuilds: ctx.pendingBuilds,
                        shamefullyFlatten: opts.shamefullyFlatten,
                        hoistedAliases: ctx.hoistedAliases,
                    }),
            ]);
            // postinstall hooks
            if (!(opts.ignoreScripts || !result.newDepPaths || !result.newDepPaths.length)) {
                const limitChild = pLimit(opts.childConcurrency);
                yield Promise.all(R.props(result.newDepPaths, result.linkedPkgsMap)
                    .filter(pkg => !pkg.isBuilt)
                    .map(pkg => limitChild(() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const hasSideEffects = yield postInstall_1.default(pkg.peripheralLocation, {
                            rawNpmConfig: installCtx.rawNpmConfig,
                            initialWD: ctx.root,
                            userAgent: opts.userAgent,
                            pkgId: pkg.id,
                            unsafePerm: opts.unsafePerm || false,
                        });
                        if (hasSideEffects && opts.sideEffectsCache && !opts.sideEffectsCacheReadonly) {
                            try {
                                yield installCtx.storeController.upload(pkg.peripheralLocation, {
                                    engine: ENGINE_NAME,
                                    pkgId: pkg.id,
                                });
                            }
                            catch (err) {
                                if (err && err.statusCode === 403) {
                                    logger_1.default.warn(`The store server disabled upload requests, could not upload ${pkg.id}`);
                                }
                                else {
                                    logger_1.default.warn({
                                        message: `An error occurred while uploading ${pkg.id}`,
                                        err,
                                    });
                                }
                            }
                        }
                    }
                    catch (err) {
                        if (installCtx.installs[pkg.id].optional) {
                            logger_1.default.warn({
                                message: `Skipping failed optional dependency ${pkg.id}`,
                                err,
                            });
                            return;
                        }
                        throw err;
                    }
                }))));
            }
            if (installCtx.localPackages.length) {
                const linkOpts = Object.assign({}, opts, { skipInstall: true, linkToBin: opts.bin });
                yield Promise.all(installCtx.localPackages.map((localPackage) => __awaiter(this, void 0, void 0, function* () {
                    yield link_1.default(localPackage.resolution.directory, opts.prefix, linkOpts);
                    logInstallStatus_1.default({
                        status: 'installed',
                        pkgId: localPackage.id,
                    });
                })));
            }
        }
        // waiting till the skipped packages are downloaded to the store
        yield Promise.all(R.props(Array.from(installCtx.skipped), installCtx.installs)
            .filter(Boolean)
            .map(pkg => pkg.fetchingFiles));
        // waiting till package requests are finished
        yield Promise.all(R.values(installCtx.installs).map(installed => installed.finishing));
        loggers_1.summaryLogger.info(undefined);
        yield opts.storeController.close();
    });
}
function buildTree(ctx, parentNodeId, parentId, children, depth, installable) {
    const childrenNodeIds = {};
    for (const child of children) {
        if (nodeIdUtils_1.nodeIdContainsSequence(parentNodeId, parentId, child.pkgId)) {
            continue;
        }
        const childNodeId = nodeIdUtils_1.createNodeId(parentNodeId, child.pkgId);
        childrenNodeIds[child.alias] = childNodeId;
        installable = installable && !ctx.skipped.has(child.pkgId);
        ctx.tree[childNodeId] = {
            pkg: ctx.installs[child.pkgId],
            children: () => buildTree(ctx, childNodeId, child.pkgId, ctx.childrenByParentId[child.pkgId], depth + 1, installable),
            depth,
            installable,
        };
    }
    return childrenNodeIds;
}
function getTopParents(pkgNames, modules) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgs = yield Promise.all(pkgNames.map(pkgName => path.join(modules, pkgName)).map(safeReadPkg_1.fromDir));
        return pkgs.filter(Boolean).map((pkg) => ({
            name: pkg.name,
            version: pkg.version,
        }));
    });
}
function getPref(alias, name, version, opts) {
    let prefix = alias !== name ? `npm:${name}@` : '';
    if (opts.saveExact)
        return `${prefix}${version}`;
    return `${prefix}${opts.savePrefix}${version}`;
}
//# sourceMappingURL=install.js.map