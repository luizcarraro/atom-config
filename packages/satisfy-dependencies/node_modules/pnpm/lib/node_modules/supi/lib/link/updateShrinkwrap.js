"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dp = require("dependency-path");
const shrinkwrap_1 = require("../fs/shrinkwrap");
const pnpm_shrinkwrap_1 = require("pnpm-shrinkwrap");
const R = require("ramda");
function default_1(pkgsToLink, shrinkwrap, pkg) {
    shrinkwrap.packages = shrinkwrap.packages || {};
    for (const resolvedId of R.keys(pkgsToLink)) {
        const shortId = dp.relative(shrinkwrap.registry, resolvedId);
        const result = R.partition((childResolvedId) => pkgsToLink[resolvedId].optionalDependencies.has(pkgsToLink[childResolvedId].name), pkgsToLink[resolvedId].children);
        shrinkwrap.packages[shortId] = toShrDependency({
            resolvedId,
            id: pkgsToLink[resolvedId].id,
            shortId,
            resolution: pkgsToLink[resolvedId].resolution,
            updatedOptionalDeps: result[0],
            updatedDeps: result[1],
            registry: shrinkwrap.registry,
            pkgsToLink,
            prevResolvedDeps: shrinkwrap.packages[shortId] && shrinkwrap.packages[shortId].dependencies || {},
            prevResolvedOptionalDeps: shrinkwrap.packages[shortId] && shrinkwrap.packages[shortId].optionalDependencies || {},
            dev: pkgsToLink[resolvedId].dev,
            optional: pkgsToLink[resolvedId].optional,
        });
    }
    return pnpm_shrinkwrap_1.prune(shrinkwrap, pkg);
}
exports.default = default_1;
function toShrDependency(opts) {
    const shrResolution = toShrResolution(opts.shortId, opts.resolution);
    const newResolvedDeps = updateResolvedDeps(opts.prevResolvedDeps, opts.updatedDeps, opts.registry, opts.pkgsToLink);
    const newResolvedOptionalDeps = updateResolvedDeps(opts.prevResolvedOptionalDeps, opts.updatedOptionalDeps, opts.registry, opts.pkgsToLink);
    const result = {
        resolution: shrResolution
    };
    if (!R.isEmpty(newResolvedDeps)) {
        result['dependencies'] = newResolvedDeps;
    }
    if (!R.isEmpty(newResolvedOptionalDeps)) {
        result['optionalDependencies'] = newResolvedOptionalDeps;
    }
    if (opts.dev) {
        result['dev'] = true;
    }
    if (opts.optional) {
        result['optional'] = true;
    }
    if (opts.resolvedId !== opts.id) {
        result['id'] = opts.id;
    }
    return result;
}
// previous resolutions should not be removed from shrinkwrap
// as installation might not reanalize the whole dependency tree
// the `depth` property defines how deep should dependencies be checked
function updateResolvedDeps(prevResolvedDeps, updatedDeps, registry, pkgsToLink) {
    const newResolvedDeps = R.fromPairs(R.props(updatedDeps, pkgsToLink)
        .map((dep) => [
        dep.name,
        shrinkwrap_1.pkgIdToRef(dep.resolvedId, dep.name, dep.resolution, registry)
    ]));
    return R.merge(prevResolvedDeps, newResolvedDeps);
}
function toShrResolution(shortId, resolution) {
    if (shortId.startsWith('/') && resolution.type === undefined && resolution.integrity) {
        return {
            integrity: resolution.integrity,
        };
    }
    return resolution;
}
//# sourceMappingURL=updateShrinkwrap.js.map