"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const isCI = require("is-ci");
const readPkg_1 = require("../fs/readPkg");
const writePkg = require("write-pkg");
const pnpm_shrinkwrap_1 = require("pnpm-shrinkwrap");
const modulesController_1 = require("../fs/modulesController");
const mkdirp = require("mkdirp-promise");
const normalizePath = require("normalize-path");
const removeAllExceptOuterLinks = require("remove-all-except-outer-links");
const logger_1 = require("@pnpm/logger");
const R = require("ramda");
const checkCompatibility_1 = require("./checkCompatibility");
const loggers_1 = require("../loggers");
function getContext(opts, installType) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = normalizePath(opts.prefix);
        const storePath = opts.store;
        const modulesPath = path.join(root, 'node_modules');
        const modules = yield modulesController_1.read(modulesPath);
        if (modules) {
            try {
                if (Boolean(modules.independentLeaves) !== opts.independentLeaves) {
                    if (modules.independentLeaves) {
                        throw new Error(`This node_modules was installed with --independent-leaves option.
            Use this option or run same command with --force to recreated node_modules`);
                    }
                    throw new Error(`This node_modules was not installed with the --independent-leaves option.
          Don't use --independent-leaves run same command with --force to recreated node_modules`);
                }
                if (Boolean(modules.shamefullyFlatten) !== opts.shamefullyFlatten) {
                    if (modules.shamefullyFlatten) {
                        throw new Error(`This node_modules was installed with --shamefully-flatten option.
            Use this option or run same command with --force to recreated node_modules`);
                    }
                    throw new Error(`This node_modules was not installed with the --shamefully-flatten option.
          Don't use --shamefully-flatten or run same command with --force to recreated node_modules`);
                }
                checkCompatibility_1.default(modules, { storePath, modulesPath });
            }
            catch (err) {
                if (!opts.force)
                    throw err;
                if (installType !== 'general') {
                    throw new Error('Named installation cannot be used to regenerate the node_modules structure. Run pnpm install --force');
                }
                logger_1.default.info(`Recreating ${modulesPath}`);
                yield removeAllExceptOuterLinks(modulesPath);
                return getContext(opts);
            }
        }
        // ignore `shrinkwrap.yaml` on CI servers
        // a latest pnpm should not break all the builds
        const shrOpts = { ignoreIncompatible: opts.force || isCI };
        const files = yield Promise.all([
            (opts.global ? readGlobalPkgJson(opts.prefix) : readPkg_1.fromDir(opts.prefix)),
            opts.shrinkwrap && pnpm_shrinkwrap_1.readWanted(root, shrOpts)
                || (yield pnpm_shrinkwrap_1.existsWanted(root)) && logger_1.default.warn('A shrinkwrap.yaml file exists. The current configuration prohibits to read or write a shrinkwrap file'),
            pnpm_shrinkwrap_1.readCurrent(root, shrOpts),
            mkdirp(storePath),
        ]);
        const currentShrinkwrap = files[2] || pnpm_shrinkwrap_1.create(opts.registry);
        const ctx = {
            pkg: files[0],
            root,
            storePath,
            wantedShrinkwrap: files[1] || !opts.shrinkwrap && currentShrinkwrap && R.clone(currentShrinkwrap) || pnpm_shrinkwrap_1.create(opts.registry),
            currentShrinkwrap,
            existsWantedShrinkwrap: !!files[1],
            existsCurrentShrinkwrap: !!files[2],
            skipped: new Set(modules && modules.skipped || []),
            pendingBuilds: modules && modules.pendingBuilds || [],
            hoistedAliases: modules && modules.hoistedAliases || {},
        };
        loggers_1.packageJsonLogger.debug({ initial: ctx.pkg });
        return ctx;
    });
}
exports.default = getContext;
const DefaultGlobalPkg = {
    name: 'pnpm-global-pkg',
    version: '1.0.0',
    private: true,
};
function readGlobalPkgJson(globalPkgPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const globalPkgJson = yield readPkg_1.fromDir(globalPkgPath);
            return globalPkgJson;
        }
        catch (err) {
            yield writePkg(globalPkgPath, DefaultGlobalPkg);
            return DefaultGlobalPkg;
        }
    });
}
//# sourceMappingURL=getContext.js.map