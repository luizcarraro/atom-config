"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const server_1 = require("@pnpm/server");
const store_path_1 = require("@pnpm/store-path");
const Diable = require("diable");
const getPort = require("get-port");
const fs = require("graceful-fs");
const isWindows = require("is-windows");
const mkdirp = require("mkdirp-promise");
const path = require("path");
const onExit = require("signal-exit");
const writeJsonFile = require("write-json-file");
const createStore_1 = require("../../createStore");
exports.default = (opts) => __awaiter(this, void 0, void 0, function* () {
    if (opts.protocol === 'ipc' && opts.port) {
        throw new Error('Port cannot be selected when server communicates via IPC');
    }
    if (opts.background && !Diable.isDaemon()) {
        Diable();
    }
    const store = yield createStore_1.default(Object.assign(opts, {
        store: yield store_path_1.default(opts.prefix, opts.store),
    }));
    // the store folder will be needed because server will want to create a file there
    // for the IPC connection
    yield mkdirp(store.path);
    const protocol = opts.protocol || opts.port && 'tcp' || 'auto';
    const serverOptions = yield getServerOptions(store.path, { protocol, port: opts.port });
    const connectionOptions = {
        remotePrefix: serverOptions.path
            ? `http://unix:${serverOptions.path}:`
            : `http://${serverOptions.hostname}:${serverOptions.port}`,
    };
    const serverJsonPath = path.join(store.path, 'server.json');
    yield writeJsonFile(serverJsonPath, {
        connectionOptions,
        pid: process.pid,
    });
    const server = server_1.createServer(store.ctrl, Object.assign({}, serverOptions, { ignoreStopRequests: opts.ignoreStopRequests, ignoreUploadRequests: opts.ignoreUploadRequests }));
    onExit(() => {
        server.close();
        fs.unlinkSync(serverJsonPath);
    });
});
function getServerOptions(fsPath, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (opts.protocol) {
            case 'tcp':
                return yield getTcpOptions();
            case 'ipc':
                if (isWindows()) {
                    throw new Error('IPC protocol is not supported on Windows currently');
                }
                return getIpcOptions();
            case 'auto':
                if (isWindows()) {
                    return yield getTcpOptions();
                }
                return getIpcOptions();
            default:
                throw new Error(`Protocol ${opts.protocol} is not supported`);
        }
        function getTcpOptions() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    hostname: 'localhost',
                    port: opts.port || (yield getPort({ port: 5813 })),
                };
            });
        }
        function getIpcOptions() {
            return {
                path: path.normalize(fsPath) + path.sep + 'socket',
            };
        }
    });
}
//# sourceMappingURL=start.js.map